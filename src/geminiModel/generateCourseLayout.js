import { model, generationConfig } from "../utils/geminiModelConfig.js";

const generateCourseLayout = model.startChat({
  generationConfig,
  history: [
    {
      role: "user",
      parts: [
        {
          text: '"Generate a comprehensive and structured course outline based on the following inputs:\nCourse Title: java \nCourse Description: oops in java\nDifficulty Level (Easy / Intermediate / Hard): Hard\nCourse Structure Requirements:\nThe course should be well-organized with a logical progression from foundational concepts to advanced topics. Each chapter should be designed to build upon the previous one, ensuring a seamless learning experience.\n\n1. Course Chapters\nEach chapter should be structured as follows:\nChapter Title (Concise and descriptive)\nChapter Description (Briefly explain what the chapter covers and its significance in the learning path.)\nTopics Covered:\nTopic Title (A specific concept covered within the chapter.)\nTopic Description (Explain the topic concisely, highlighting its importance.)\nSubtopics: (Break down the topic into smaller, digestible sections for in-depth understanding.)\nSubtopic 1 (Short explanation.)... (Expand as necessary.)\nSub sub topics (Short explanation.) (Expand as necessary.)\n\n\nChapter should be divided properly no matter chapter go till 25\n\nEnsure the course follows a progressive learning path, introducing foundational concepts before advanced ones. Keep descriptions concise yet informative. Structure content to maximize engagement and comprehension.\n\n\nResponse in JSON format, no preamble \n\n',
        },
      ],
    },
    {
      role: "model",
      parts: [
        {
          text: '```json\n{\n  "courseTitle": "Java: Advanced Object-Oriented Programming",\n  "courseDescription": "A deep dive into advanced object-oriented programming concepts in Java, focusing on design patterns, concurrency, and performance optimization.",\n  "difficultyLevel": "Hard",\n  "courseStructure": [\n    {\n      "chapterTitle": "Java Fundamentals Review and Advanced Data Structures",\n      "chapterDescription": "Revisits core Java concepts and introduces advanced data structures essential for complex OOP applications.",\n      "topicsCovered": [\n        {\n          "topicTitle": "Java Core Review",\n          "topicDescription": "Refreshes essential Java syntax, data types, control flow, and I/O operations.",\n          "subtopics": [\n            "Data Types and Variables: Revisiting primitive and reference types.",\n            "Operators: Arithmetic, logical, bitwise, and assignment operators.",\n            "Control Flow: If-else statements, loops (for, while, do-while).",\n            "Input/Output Streams: Reading from and writing to files and console."\n          ]\n        },\n        {\n          "topicTitle": "Advanced Data Structures",\n          "topicDescription": "Explores complex data structures like Trees, Graphs, and HashMaps beyond basic usage.",\n          "subtopics": [\n            "Trees: Binary Trees, AVL Trees, Red-Black Trees - properties, insertion, deletion, and search.",\n            "Graphs: Adjacency matrix and list representations, graph traversal algorithms (BFS, DFS).",\n            "HashMaps and Hash Functions: Understanding collisions, separate chaining, open addressing, and custom hash function implementations.",\n            "Priority Queues and Heaps: Binary heaps, binomial heaps, and their applications."\n          ]\n        }\n      ]\n    },\n    {\n      "chapterTitle": "Advanced Object-Oriented Principles",\n      "chapterDescription": "Delves deeper into OOP concepts like abstraction, polymorphism, inheritance, and encapsulation.",\n      "topicsCovered": [\n        {\n          "topicTitle": "Advanced Abstraction",\n          "topicDescription": "Exploring the use of abstract classes and interfaces to create flexible and maintainable code.",\n          "subtopics": [\n            "Abstract Classes vs. Interfaces: When to use each and their differences.",\n            "Abstract Methods: Defining abstract methods and implementing them in subclasses.",\n            "Functional Interfaces: Introduction to functional interfaces and lambda expressions."\n          ]\n        },\n        {\n          "topicTitle": "Polymorphism and Dynamic Binding",\n          "topicDescription": "Understanding compile-time (static) and runtime (dynamic) polymorphism in detail.",\n          "subtopics": [\n            "Method Overloading: Creating methods with the same name but different parameters.",\n            "Method Overriding: Overriding methods in subclasses and the \'super\' keyword.",\n            "Dynamic Method Dispatch: Resolving method calls at runtime."\n          ]\n        },\n        {\n          "topicTitle": "Advanced Inheritance",\n          "topicDescription": "Exploring multiple inheritance using interfaces and composition.",\n          "subtopics": [\n            "Interface Inheritance: Implementing multiple interfaces in a class.",\n            "Composition over Inheritance: Favoring composition to achieve code reuse.",\n            "The Diamond Problem: Understanding and avoiding the diamond problem."\n          ]\n        }\n      ]\n    },\n    {\n      "chapterTitle": "Design Patterns - Creational Patterns",\n      "chapterDescription": "Introduces creational design patterns, focusing on object creation mechanisms.",\n      "topicsCovered": [\n        {\n          "topicTitle": "Singleton Pattern",\n          "topicDescription": "Ensuring only one instance of a class exists and providing a global point of access to it.",\n          "subtopics": [\n            "Eager Initialization: Creating the instance at class loading time.",\n            "Lazy Initialization: Creating the instance when it\'s first needed.",\n            "Thread-Safe Singleton: Handling concurrency issues in multi-threaded environments.",\n            "Double-Checked Locking: Optimizing thread-safe singleton implementations."\n          ]\n        },\n        {\n          "topicTitle": "Factory Pattern",\n          "topicDescription": "Providing an interface for creating objects without specifying their concrete classes.",\n          "subtopics": [\n            "Simple Factory: Centralized object creation.",\n            "Factory Method: Defining an interface for creating an object, but letting subclasses decide which class to instantiate.",\n            "Abstract Factory: Creating families of related objects."\n          ]\n        },\n        {\n          "topicTitle": "Builder Pattern",\n          "topicDescription": "Constructing complex objects step by step, allowing for different representations.",\n          "subtopics": [\n            "Director: Defining the steps for constructing the object.",\n            "Builder: Abstract interface for creating parts of the object.",\n            "Concrete Builders: Implementing the builder interface to create specific object representations."\n          ]\n        },\n         {\n          "topicTitle": "Prototype Pattern",\n          "topicDescription": "Creating new objects by cloning existing ones.",\n          "subtopics": [\n            "Shallow Copy vs. Deep Copy: Understanding the difference and implementing appropriate cloning strategies.",\n            "Cloning Interfaces: Implementing the Cloneable interface.",\n            "Using Serialization for Deep Copy: Creating a deep copy using object serialization."\n          ]\n        }\n      ]\n    },\n    {\n      "chapterTitle": "Design Patterns - Structural Patterns",\n      "chapterDescription": "Explores structural design patterns, focusing on object composition and relationships.",\n      "topicsCovered": [\n        {\n          "topicTitle": "Adapter Pattern",\n          "topicDescription": "Allowing incompatible interfaces to work together.",\n          "subtopics": [\n            "Class Adapter: Using inheritance to adapt interfaces.",\n            "Object Adapter: Using composition to adapt interfaces.",\n            "Two-Way Adapter: Adapting interfaces in both directions."\n          ]\n        },\n        {\n          "topicTitle": "Bridge Pattern",\n          "topicDescription": "Decoupling an abstraction from its implementation so that the two can vary independently.",\n          "subtopics": [\n            "Abstraction: Defining the high-level control.",\n            "Implementor: Defining the low-level implementation.",\n            "Refined Abstraction: Extending the abstraction."\n          ]\n        },\n        {\n          "topicTitle": "Composite Pattern",\n          "topicDescription": "Composing objects into tree structures to represent part-whole hierarchies.",\n          "subtopics": [\n            "Component: Defining the interface for objects in the composition.",\n            "Leaf: Representing the individual objects.",\n            "Composite: Representing the containers of components."\n          ]\n        },\n        {\n          "topicTitle": "Decorator Pattern",\n          "topicDescription": "Adding responsibilities to objects dynamically.",\n          "subtopics": [\n            "Component: Defining the interface for objects that can have responsibilities added to them dynamically.",\n            "Concrete Component: Defining an object to which responsibilities can be added.",\n            "Decorator: Maintaining a reference to a Component object and defining an interface that conforms to Component\'s interface.",\n            "Concrete Decorators: Adding responsibilities to the component."\n          ]\n        },\n        {\n          "topicTitle": "Facade Pattern",\n          "topicDescription": "Providing a simplified interface to a complex subsystem.",\n          "subtopics": [\n            "Facade Class: Providing a high-level interface.",\n            "Subsystem Classes: Implementing the complex functionality."\n          ]\n        },\n        {\n          "topicTitle": "Flyweight Pattern",\n          "topicDescription": "Using sharing to support large numbers of fine-grained objects efficiently.",\n          "subtopics": [\n            "Intrinsic State: State that is stored in the Flyweight object.",\n            "Extrinsic State: State that is passed to the Flyweight object.",\n            "Flyweight Factory: Managing the creation and sharing of Flyweight objects."\n          ]\n        },\n        {\n          "topicTitle": "Proxy Pattern",\n          "topicDescription": "Providing a surrogate or placeholder for another object to control access to it.",\n          "subtopics": [\n            "Virtual Proxy: Creating expensive objects on demand.",\n            "Remote Proxy: Representing an object on a different machine.",\n            "Protection Proxy: Controlling access to an object based on access rights."\n          ]\n        }\n      ]\n    },\n    {\n      "chapterTitle": "Design Patterns - Behavioral Patterns",\n      "chapterDescription": "Focuses on behavioral design patterns, addressing object interactions and responsibilities.",\n      "topicsCovered": [\n        {\n          "topicTitle": "Chain of Responsibility Pattern",\n          "topicDescription": "Avoiding coupling the sender of a request to its receiver by giving multiple objects a chance to handle the request.",\n          "subtopics": [\n            "Handler: Defining the interface for handling requests.",\n            "Concrete Handlers: Handling the request or passing it to the next handler in the chain.",\n            "Client: Initiating the request."\n          ]\n        },\n        {\n          "topicTitle": "Command Pattern",\n          "topicDescription": "Encapsulating a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.",\n          "subtopics": [\n            "Command: Defining the interface for executing an operation.",\n            "Concrete Commands: Implementing the Command interface and binding a receiver object to an action.",\n            "Invoker: Asking the command to carry out the request.",\n            "Receiver: Performing the action."\n          ]\n        },\n        {\n          "topicTitle": "Interpreter Pattern",\n          "topicDescription": "Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.",\n          "subtopics": [\n            "Abstract Expression: Declaring an interface for all nonterminal and terminal expressions.",\n            "Terminal Expression: Implementing the Abstract Expression interface for terminal symbols.",\n            "Nonterminal Expression: Implementing the Abstract Expression interface for nonterminal symbols.",\n            "Context: Containing information that is global to the interpreter."\n          ]\n        },\n        {\n          "topicTitle": "Iterator Pattern",\n          "topicDescription": "Providing a way to access the elements of an aggregate object sequentially without exposing its underlying representation.",\n          "subtopics": [\n            "Iterator: Defining the interface for accessing and traversing elements.",\n            "Concrete Iterator: Implementing the Iterator interface.",\n            "Aggregate: Defining the interface for creating an Iterator object.",\n            "Concrete Aggregate: Implementing the Aggregate interface."\n          ]\n        },\n        {\n          "topicTitle": "Mediator Pattern",\n          "topicDescription": "Defining an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and lets you vary their interaction independently.",\n          "subtopics": [\n            "Mediator: Defining the interface for communicating with Colleague objects.",\n            "Concrete Mediator: Implementing the Mediator interface and coordinating interactions between Colleague objects.",\n            "Colleague: Defining the interface for communicating with the Mediator object.",\n            "Concrete Colleagues: Communicating with the Mediator object."\n          ]\n        },\n        {\n          "topicTitle": "Memento Pattern",\n          "topicDescription": "Without violating encapsulation, capture and externalize an object\'s internal state so that the object can be restored to this state later.",\n          "subtopics": [\n            "Originator: Creating a memento containing a snapshot of its internal state.",\n            "Memento: Storing the internal state of the Originator object.",\n            "Caretaker: Keeping track of multiple Mementos."\n          ]\n        },\n        {\n          "topicTitle": "Observer Pattern",\n          "topicDescription": "Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.",\n          "subtopics": [\n            "Subject: Maintaining a list of Observers and notifying them of state changes.",\n            "Observer: Defining the interface for objects that are notified of state changes.",\n            "Concrete Subject: Notifying Observers when its state changes.",\n            "Concrete Observers: Reacting to state changes."\n          ]\n        },\n        {\n          "topicTitle": "State Pattern",\n          "topicDescription": "Allowing an object to alter its behavior when its internal state changes. The object will appear to change its class.",\n          "subtopics": [\n            "State: Defining an interface for encapsulating the behavior associated with a particular state of the Context.",\n            "Concrete States: Implementing the State interface and providing state-specific behavior.",\n            "Context: Defining the interface of interest to clients and maintaining an instance of a ConcreteState subclass, which defines the current state."\n          ]\n        },\n        {\n          "topicTitle": "Strategy Pattern",\n          "topicDescription": "Defining a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.",\n          "subtopics": [\n            "Strategy: Defining the interface for algorithms.",\n            "Concrete Strategies: Implementing the Strategy interface.",\n            "Context: Maintaining a reference to a Strategy object and delegating algorithm execution to it."\n          ]\n        },\n        {\n          "topicTitle": "Template Method Pattern",\n          "topicDescription": "Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm\'s structure.",\n          "subtopics": [\n            "Abstract Class: Defining the template method.",\n            "Concrete Classes: Implementing the abstract methods."\n          ]\n        },\n        {\n          "topicTitle": "Visitor Pattern",\n          "topicDescription": "Representing an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.",\n          "subtopics": [\n            "Visitor: Defining the interface for visiting elements.",\n            "Concrete Visitors: Implementing the Visitor interface and performing operations on specific elements.",\n            "Element: Defining the interface for accepting a Visitor.",\n            "Concrete Elements: Implementing the Element interface and allowing a Visitor to access their internal state."\n          ]\n        }\n      ]\n    },\n    {\n      "chapterTitle": "Concurrency and Multithreading",\n      "chapterDescription": "Covers advanced concurrency concepts and techniques for building multi-threaded applications.",\n      "topicsCovered": [\n        {\n          "topicTitle": "Threads and Processes",\n          "topicDescription": "Understanding the differences between threads and processes and their roles in concurrent programming.",\n          "subtopics": [\n            "Thread Creation: Using Runnable interface and Thread class.",\n            "Thread Lifecycle: States of a thread (New, Runnable, Running, Blocked, Terminated).",\n            "Thread Priorities: Understanding thread priority and its impact on scheduling.",\n            "Daemon Threads: Understanding and using daemon threads."\n          ]\n        },\n        {\n          "topicTitle": "Synchronization",\n          "topicDescription": "Managing shared resources and preventing race conditions using synchronization techniques.",\n          "subtopics": [\n            "Synchronized Methods: Using synchronized keyword to protect critical sections.",\n            "Synchronized Blocks: Using synchronized blocks for finer-grained control.",\n            "Intrinsic Locks: Understanding the concept of intrinsic locks (monitors).",\n            "Reentrant Locks: Understanding ReentrantLock class and its advantages."\n          ]\n        },\n        {\n          "topicTitle": "Inter-Thread Communication",\n          "topicDescription": "Enabling threads to communicate and coordinate using wait(), notify(), and notifyAll().",\n          "subtopics": [\n            "Wait and Notify: Using wait() and notify() methods for thread signaling.",\n            "Blocking Queues: Using BlockingQueue interface for safe thread communication.",\n            "Producer-Consumer Problem: Implementing a solution to the producer-consumer problem."\n          ]\n        },\n        {\n          "topicTitle": "Concurrency Utilities",\n          "topicDescription": "Leveraging Java\'s concurrency utilities for building robust concurrent applications.",\n          "subtopics": [\n            "Executors: Using ExecutorService for managing thread pools.",\n            "Futures: Representing the result of an asynchronous computation.",\n            "Callable: Defining tasks that return a result.",\n            "CountDownLatch: Synchronizing threads based on a counter.",\n            "CyclicBarrier: Synchronizing threads at a barrier point.",\n            "Semaphore: Controlling access to a limited number of resources."\n          ]\n        },\n        {\n          "topicTitle": "Thread Pools",\n          "topicDescription": "Explore various thread pool implementations and their benefits.",\n          "subtopics": [\n            "FixedThreadPool: Thread pool with a fixed number of threads.",\n            "CachedThreadPool: Thread pool that creates new threads as needed.",\n            "ScheduledThreadPool: Thread pool for scheduling tasks.",\n            "ForkJoinPool: Thread pool for recursive tasks."\n          ]\n        },\n        {\n          "topicTitle": "Atomic Variables",\n          "topicDescription": "Understand the use of atomic variables for lock-free concurrency.",\n          "subtopics": [\n            "AtomicInteger: Atomic integer operations.",\n            "AtomicLong: Atomic long operations.",\n            "AtomicBoolean: Atomic boolean operations.",\n            "Compare-and-Swap (CAS) operations: Understanding the CAS mechanism."\n          ]\n        },\n        {\n          "topicTitle": "Deadlocks and Livelocks",\n          "topicDescription": "Learn how to identify and prevent deadlocks and livelocks in concurrent applications.",\n          "subtopics": [\n            "Deadlock Conditions: Mutual exclusion, hold and wait, no preemption, circular wait.",\n            "Deadlock Prevention Techniques: Avoiding deadlock conditions.",\n            "Livelock: Understanding livelock and its causes."\n          ]\n        }\n      ]\n    },\n     {\n      "chapterTitle": "Generics Deep Dive",\n      "chapterDescription": "Exploring advanced features of generics including bounded type parameters, wildcards, and type erasure.",\n      "topicsCovered": [\n        {\n          "topicTitle": "Bounded Type Parameters",\n          "topicDescription": "Restricting the types that can be used as type parameters.",\n          "subtopics": [\n            "Upper Bounded Type Parameters: Limiting types to subclasses of a specific class or interface.",\n            "Lower Bounded Type Parameters: Limiting types to superclasses of a specific class.",\n            "Multiple Bounds: Combining upper and lower bounds."\n          ]\n        },\n        {\n          "topicTitle": "Wildcards",\n          "topicDescription": "Using wildcards to create flexible generic types.",\n          "subtopics": [\n            "Upper Bounded Wildcards: Specifying an upper bound for the wildcard type.",\n            "Lower Bounded Wildcards: Specifying a lower bound for the wildcard type.",\n            "Unbounded Wildcards: Using wildcards without any bounds."\n          ]\n        },\n        {\n          "topicTitle": "Type Erasure",\n          "topicDescription": "Understanding how generics are implemented in Java and the implications of type erasure.",\n          "subtopics": [\n            "Erasure Process: How the compiler removes type parameters during compilation.",\n            "Bridge Methods: Creating bridge methods to maintain type safety.",\n            "Limitations of Type Erasure: Restrictions on using generics with primitive types and instanceof operator."\n          ]\n        },\n        {\n          "topicTitle": "Generic Methods",\n          "topicDescription": "Creating generic methods that can operate on different types.",\n          "subtopics": [\n            "Type Inference: How the compiler infers type parameters for generic methods.",\n            "Static Generic Methods: Using generics in static methods.",\n            "Generic Constructor",\n            "Using generics in constructor",\n            "Generic Interface Implementation: Implementing generic interfaces in classes."\n          ]\n        },\n        {\n          "topicTitle": "Generic Class Extension",\n          "topicDescription": "Understand how generic classes can be extended and inherit type parameters.",\n          "subtopics": [\n            "Extending Generic Classes: Inheriting type parameters from parent classes.",\n            "Adding New Type Parameters: Adding new type parameters in subclasses.",\n            "Using Raw Types: Risks of using raw types and how to avoid them."\n          ]\n        }\n      ]\n    },\n      {\n      "chapterTitle": "Reflection API",\n      "chapterDescription": "In depth study of reflection api.",\n      "topicsCovered": [\n        {\n          "topicTitle": "Class Metadata",\n          "topicDescription": "Exploring the use of reflection to access class metadata at runtime.",\n          "subtopics": [\n            "Getting Class Information: Retrieving information about a class, such as its name, modifiers, and interfaces.",\n            "Accessing Fields: Getting and setting the values of fields.",\n            "Invoking Methods: Calling methods dynamically.",\n            "Creating Objects: Instantiating objects at runtime."\n          ]\n        },\n        {\n          "topicTitle": "Accessing Private Members",\n          "topicDescription": "Bypassing access restrictions to access private fields and methods.",\n          "subtopics": [\n            "Setting Accessible Flag: Using the setAccessible() method to access private members.",\n            "Working with Private Fields: Getting and setting the values of private fields.",\n            "Invoking Private Methods: Calling private methods dynamically."\n          ]\n        },\n        {\n          "topicTitle": "Working with Annotations",\n          "topicDescription": "Using reflection to read and process annotations at runtime.",\n          "subtopics": [\n            "Getting Annotations: Retrieving annotations from classes, methods, and fields.",\n            "Processing Annotations: Reading and processing annotation values.",\n            "Custom Annotations: Creating and using custom annotations."\n          ]\n        },\n        {\n          "topicTitle": "Dynamic Proxy",\n          "topicDescription": "Creating dynamic proxies to intercept method calls.",\n          "subtopics": [\n            "Proxy Interface: Defining the interface that the proxy implements.",\n            "Invocation Handler: Implementing the InvocationHandler interface to intercept method calls.",\n            "Creating Proxy Objects: Creating proxy objects using the Proxy class."\n          ]\n        },\n        {\n          "topicTitle": "Limitations and Best Practices",\n          "topicDescription": "Understanding the limitations and best practices for using reflection.",\n          "subtopics": [\n            "Performance Considerations: Reflection can be slower than direct method calls.",\n            "Security Risks: Reflection can be used to bypass security restrictions.",\n            "Maintainability: Reflection can make code harder to understand and maintain."\n          ]\n        }\n      ]\n    },\n    {\n       "chapterTitle": "IO",\n      "chapterDescription": "In depth study of IO.",\n      "topicsCovered": [\n        {\n          "topicTitle": "Streams API",\n          "topicDescription": "Understanding the Streams API for processing sequences of elements.",\n          "subtopics": [\n            "Stream Creation: Creating streams from collections, arrays, and other sources.",\n            "Intermediate Operations: Filtering, mapping, and sorting elements in a stream.",\n            "Terminal Operations: Collecting, reducing, and finding elements in a stream.",\n            "Parallel Streams: Processing streams in parallel."\n          ]\n        },\n        {\n          "topicTitle": "NIO API",\n          "topicDescription": "Exploring the New I/O (NIO) API for high-performance I/O operations.",\n          "subtopics": [\n            "Channels: Channels for reading and writing data.",\n            "Buffers: Buffers for storing data.",\n            "Selectors: Selectors for multiplexing I/O operations.",\n            "Asynchronous Channels: Asynchronous channels for non-blocking I/O operations."\n          ]\n        },\n        {\n          "topicTitle": "Path API",\n          "topicDescription": "Using the Path API for working with files and directories.",\n          "subtopics": [\n            "Path Creation: Creating Path objects for files and directories.",\n            "Path Operations: Getting file attributes, creating directories, and deleting files.",\n            "Path Walking: Walking the file tree."\n          ]\n        },\n        {\n          "topicTitle": "Serialization",\n          "topicDescription": "Serialization and Deserialization of java objects.",\n          "subtopics": [\n            "The Serializable Interface: Make your objects serializable",\n            "Write Object: Write objects to stream",\n            "Read Objects: Read objects from stream.",\n            "Custom Serialization: Custom the serialization of java objects."\n          ]\n        }\n      ]\n    },\n    {\n      "chapterTitle": "Unit Testing",\n      "chapterDescription": "Learn how to use Test Driven Development.",\n      "topicsCovered": [\n        {\n          "topicTitle": "Unit Test basics",\n          "topicDescription": "Writing Unit Test cases with frameworks.",\n          "subtopics": [\n            "Junit: Write unit test cases for java code.",\n            "TestNG: Write unit test cases for java code.",\n            "Asserts: Using assertions in unit test.",\n            "Mocks: Using Mocks in unit test."\n          ]\n        }\n      ]\n    }\n  ]\n}\n```',
        },
      ],
    },
  ],
});

export default generateCourseLayout;
